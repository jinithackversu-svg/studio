rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset establishes a dual-access security model tailored for a digital canteen system.
     * It strictly separates access between "Customers" and privileged "Canteen Operators". The default posture is denial,
     * granting permissions explicitly based on user identity and assigned roles.
     *
     * Data Structure:
     * - /customers/{customerId}: Stores private user profiles, enforcing a strict ownership model where users can only
     *   access their own data.
     * - /roles_canteen_operator/{operatorId}: A read-only (for clients) collection used to grant operator privileges. The
     *   existence of a document here signifies a user is an operator, enabling performant role checks across other rules.
     * - /menu_items/{menuItemId}: A publicly readable collection for the canteen menu. Write access is restricted to
     *   Canteen Operators.
     * - /orders/{orderId}: Contains customer orders with a mixed access model. Customers can create and manage their own
     *   orders, while Canteen Operators have read/write access to all orders for processing.
     *
     * Key Security Decisions:
     * - Role-Based Access Control (RBAC): Canteen Operator status is the primary mechanism for elevated permissions. This
     *   is determined by a fast `exists()` check on the `/roles_canteen_operator` collection, avoiding slow cross-collection queries.
     * - User Data Privacy: Listing or reading other users' customer profiles is strictly forbidden.
     * - Public vs. Private Data: The menu is segregated into its own collection to allow safe public listing, while
     *   sensitive data like orders and profiles are secured.
     * - Denormalization for Authorization: Orders must contain a denormalized `customerId` field to allow for direct
     *   ownership checks without needing to consult other documents, ensuring rules are fast and scalable.
     *
     * Structural Segregation: The use of distinct top-level collections for customers, roles, menu items, and orders
     * creates clear security boundaries. This prevents data leakage from `list` operations and simplifies the rules for
     * each collection.
     */

    // ------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * Used to enforce document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document already exists in Firestore.
     * Crucial for protecting against writes on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the requesting user is a Canteen Operator by verifying
     * the existence of a corresponding document in the roles collection.
     */
    function isCanteenOperator() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_canteen_operator/$(request.auth.uid));
    }

    /**
     * Validates that the customer `id` field within the document matches the
     * document's ID in the path, ensuring relational integrity.
     */
    function hasConsistentCustomerId(customerId) {
      // On create, check incoming data.
      // On update, check against existing data to allow partial updates.
      return request.resource.data.id == customerId || resource.data.id == customerId;
    }

    // ------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------

    /**
     * @description Manages customer profiles. Each customer can create, read, and update their own profile, but cannot
     * access or even list other customers' profiles.
     * @path /customers/{customerId}
     * @allow (create) A new user with UID 'user123' creating their own profile at `/customers/user123`.
     * @deny (get) User 'user456' trying to read the profile at `/customers/user123`.
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /customers/{customerId} {
      allow get: if isOwner(customerId);
      allow list: if false;
      allow create: if isOwner(customerId) && hasConsistentCustomerId(customerId);
      allow update: if isOwner(customerId) && isExistingDoc() && hasConsistentCustomerId(customerId);
      allow delete: if false;
    }

    /**
     * @description Stores Canteen Operator role grants. This collection is managed by backend/admin processes and is
     * not readable or writable by any client to prevent enumeration of privileged users.
     * @path /roles_canteen_operator/{operatorId}
     * @allow None. All client-side requests are denied.
     * @deny (get) Any user trying to check if `/roles_canteen_operator/user123` exists.
     * @principle Secures role-granting data by making it inaccessible to clients. Its sole purpose is for server-side rule lookups (`exists()`).
     */
    match /roles_canteen_operator/{operatorId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Defines the publicly available menu. Anyone, including unauthenticated users, can view menu items.
     * Only authenticated Canteen Operators can add, modify, or remove items.
     * @path /menu_items/{menuItemId}
     * @allow (get) An anonymous user fetching a menu item.
     * @deny (create) A regular customer attempting to add a new menu item.
     * @principle Implements a "Public Read with Role-Only Writes" security model.
     */
    match /menu_items/{menuItemId} {
      allow get: if true;
      allow list: if true;
      allow create: if isCanteenOperator();
      allow update: if isCanteenOperator() && isExistingDoc();
      allow delete: if isCanteenOperator() && isExistingDoc();
    }

    /**
     * @description Contains customer orders. Customers can create and manage their own orders. Canteen Operators can
     * read and manage all orders for fulfillment.
     * @path /orders/{orderId}
     * @allow (create) A customer with UID 'user123' creating an order with `{ customerId: 'user123' }`.
     * @deny (update) A customer 'user456' attempting to modify an order owned by 'user123'.
     * @principle Enforces a shared access model based on either document ownership or a privileged role.
     */
    match /orders/{orderId} {
      // CRITICAL: The 'Order' entity is not defined in the backend schema.
      // These rules assume an 'Order' document contains a `customerId` field that stores the UID of the user who placed the order.
      // This field is essential for enforcing ownership-based security.

      allow get: if (isCanteenOperator() || isOwner(resource.data.customerId)) && isExistingDoc();
      allow list: if isSignedIn(); // Allows queries (e.g., where('customerId', '==', uid)). Security is enforced by the 'get' rule on each returned doc.
      allow create: if isSignedIn() && request.resource.data.customerId == request.auth.uid; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if (isCanteenOperator() || isOwner(resource.data.customerId)) && isExistingDoc() && request.resource.data.customerId == resource.data.customerId;
      allow delete: if (isCanteenOperator() || isOwner(resource.data.customerId)) && isExistingDoc();
    }
  }
}